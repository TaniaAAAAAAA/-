//---------------------------------------------------------------------------

#include <vcl.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#pragma hdrstop


#include "Unit1.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm1 *Form1;
struct Elem	// Оголошення елемента черги
{ AnsiString gorod; // Рядок - назва міста
int nas;	// Ціле число - кількість населення міста
Elem *next;	// Вказівник на наступний елемент черги (адреса)
};
// Оголошення вказівників на початок і кінець черги та їхнє початкове обнулення
Elem *first=0, *last=0;
void add (AnsiString S, int d) // Долучення елемента до черги
{ Elem *c=new Elem; // Виділення пам'яті під новий елемент черги
c->gorod=S;	// Занесення до нового елемента назви міста
c->nas=d;	// Занесення до нового елемента кількості населення
c->next=0; // Після нового елемента інших елементів покищо немає if(first==0)first=c;// Якщо черги ще нема, то новий елемент стає першим else	// Інакше елемент долучається після останнього,
last->next=c; // записуючи в last адресу нового елемента

last=c;	// Тепер новий елемент стає останнім
}
void del()	// Вилучення першого елемента черги
{ if(first==0) // Якщо черга є порожня, виводиться повідомлення і виконання
{ ShowMessage("Черга порожня"); return; }	// переривається
Elem *c=first;
first=first->next;// first указує на той елемент, який раніше був другим
delete c;	// Знищення елемента, який вилучається
}
void print()	// Виведення черги в Memo
{ Form1->Memo1->Clear(); Elem *c=first; while(c!=0)
{ Form1->Memo1->Lines->Add(c->gorod+" "+IntToStr(c->nas)); c=c->next;	// Перехід до наступного елемента черги
} }
AnsiString udal()
// Вилучення з черги всіх міст до міста з максимальним населенням
{ if(first==0)	// Якщо черга є порожня,
{ ShowMessage("Черга порожня");	// виводиться повідомлення
return ""; }	// і виконання переривається
//Пошук міста з максимальним населенням
int max=first->nas;	// Початкове значення максимального населення -
// населення першого міста
AnsiString maxgor=first->gorod;	// Початкове значення міста
// з максимальним населенням - назва першого міста.
Elem *c=first->next;	// Цикл розпочинається з другого елемента черги
while(c!=0)
{if(c->nas > max) // Якщо населення міста більше максимального,
{ max=c->nas;	// у max запам'ятовується кількість населення міста
maxgor=c->gorod; } // та його назва
c=c->next;
}
// Вилучення з черги всіх міст аж до міста з максимальним населенням
c=first;
while(c!=0 && c->gorod!=maxgor)	// Допоки не дісталися міста,
{ del();//з максимальним населенням, вилучається перший елемент черги
c=first; } return maxgor;
}
void clean ()	// Очищення пам'яті
{ while(first!=0) del(); }


//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
        : TForm(Owner)
{
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Button2Click(TObject *Sender)
{
print();        
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Button3Click(TObject *Sender)
{
del(); print();        
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Button4Click(TObject *Sender)
{
Edit3->Text = udal(); print();        
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Button5Click(TObject *Sender)
{
Edit1->Clear();
Edit2->Clear();
Edit3->Clear();
Memo1->Clear();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Button6Click(TObject *Sender)
{
Close();        
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Button1Click(TObject *Sender)
{
AnsiString S=Edit1->Text; int d=StrToInt(Edit2->Text); add (S, d);        
}
//---------------------------------------------------------------------------
